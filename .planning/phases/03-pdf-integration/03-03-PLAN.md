---
phase: 03-pdf-integration
plan: 03
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - lib/pdf/pdf-extraction-worker.ts
  - lib/pdf/toc-heuristics.ts
  - components/pdf/TOCNavigation.tsx
  - components/pdf/PageRangeSelector.tsx
  - store/document-store.ts
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can see extracted table of contents when PDF has structured outline"
    - "User can navigate to specific sections via TOC"
    - "User can manually select page range when PDF lacks TOC"
    - "User can return to document navigation after reading session"
  artifacts:
    - path: "lib/pdf/toc-heuristics.ts"
      provides: "Fallback TOC detection via font size and styling heuristics"
      exports: ["detectTOCFromFonts", "extractTableOfContents"]
    - path: "components/pdf/TOCNavigation.tsx"
      provides: "Hierarchical TOC display with clickable navigation"
      min_lines: 80
    - path: "components/pdf/PageRangeSelector.tsx"
      provides: "Manual page range selection UI"
      min_lines: 60
    - path: "store/document-store.ts"
      provides: "Document state including TOC and current section"
      exports: ["useDocumentStore"]
  key_links:
    - from: "lib/pdf/pdf-extraction-worker.ts"
      to: "lib/pdf/toc-heuristics.ts"
      via: "call extractTableOfContents with PDF document"
      pattern: "extractTableOfContents\\(pdf\\)"
    - from: "components/pdf/TOCNavigation.tsx"
      to: "store/document-store.ts"
      via: "read TOC items and selected section"
      pattern: "useDocumentStore.*outline"
    - from: "components/pdf/TOCNavigation.tsx"
      to: "store/reading-store.ts"
      via: "initialize RSVP with selected section text"
      pattern: "readingStore.*initialize"
---

<objective>
Enable navigation through PDF documents via table of contents extraction and manual page selection.

Purpose: Fulfill requirements PDF-03 (extract TOC), PDF-04 (manual page range), PDF-05 (navigate sections), PDF-06 (return to TOC). Long PDFs need structured navigation - users shouldn't read entire document sequentially. TOC extraction leverages structured outlines (~30% of PDFs) with font-based heuristic fallback.

Output: Document navigation UI showing TOC hierarchy, clickable section navigation, and manual page range selection for PDFs without structured outline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-pdf-integration/03-RESEARCH.md

# Prior plan establishing worker and extraction
@.planning/phases/03-pdf-integration/03-01-SUMMARY.md
@.planning/phases/03-pdf-integration/03-02-SUMMARY.md

# Existing stores to understand state patterns
@store/reading-store.ts
@store/settings-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TOC extraction with heuristics</name>
  <files>lib/pdf/toc-heuristics.ts</files>
  <action>
Create TOC extraction module with structured outline parsing and font-based heuristic fallback:

**Import types:**
```typescript
import type { PDFDocumentProxy } from 'pdfjs-dist';
import type { TOCItem } from '@/types/pdf-worker';
```

**Main function:**
```typescript
export async function extractTableOfContents(
  pdf: PDFDocumentProxy
): Promise<TOCItem[]>
```

**Implementation strategy:**
1. Try structured outline first: `const outline = await pdf.getOutline()`
2. If outline exists and has length > 0, call parseOutlineToTOC(pdf, outline)
3. Otherwise, call detectTOCFromFonts(pdf) as fallback
4. Return TOCItem[] (may be empty if no structure detected)

**parseOutlineToTOC helper:**
- Recursive traversal of outline nodes
- For each node:
  - Resolve destination to page index using pdf.getPageIndex()
  - Handle both string destinations (named) and array destinations
  - Extract title from node.title
  - Track hierarchy level (increment on recursion)
- Return flattened TOCItem[] preserving hierarchy via level field
- Follow research pattern for destination resolution (try-catch for failed lookups)

**detectTOCFromFonts helper:**
- Scan first 20 pages (or pdf.numPages if less)
- For each page:
  - Get textContent and calculate average font size
  - Find text items with fontSize > avgSize * 1.3
  - Apply heuristic filters:
    - Length 3-100 characters (not too short, not body text)
    - Contains alphanumeric content
    - Not all uppercase (excludes headers/footers)
- Estimate hierarchy level based on font size ratio (≥2.0 = level 0, ≥1.5 = level 1, else level 2)
- Deduplicate by page+title, sort by page order
- Return TOCItem[]

**Memory management:**
Call page.cleanup() after processing each page in heuristic detection.

Follow research code examples closely - this is a well-defined algorithm.
  </action>
  <verify>Function compiles, can extract TOC from PDF with outline, returns empty array for PDFs without outline</verify>
  <done>extractTableOfContents returns TOCItem[] with title, pageIndex, level for navigation</done>
</task>

<task type="auto">
  <name>Task 2: Update worker to extract TOC</name>
  <files>lib/pdf/pdf-extraction-worker.ts</files>
  <action>
Integrate TOC extraction into worker flow:

**Import toc-heuristics:**
```typescript
import { extractTableOfContents } from './toc-heuristics';
```

**After loading PDF document, before text extraction loop:**
```typescript
const pdf = await loadingTask.promise;

// Extract TOC
const outline = await extractTableOfContents(pdf);

// (existing text extraction loop follows)
```

**Update complete message:**
Change `outline: []` to `outline` (the extracted TOC).

**Why in worker:** TOC extraction is CPU-intensive (font analysis, page scanning). Running in worker keeps main thread responsive. TOC and text extraction happen in same worker pass for efficiency.

No other changes needed - text extraction loop remains identical.
  </action>
  <verify>Worker returns populated outline field when PDF has TOC structure</verify>
  <done>Worker result includes outline: TOCItem[] with structured navigation data</done>
</task>

<task type="auto">
  <name>Task 3: Create document store for TOC state</name>
  <files>store/document-store.ts</files>
  <action>
Create Zustand store for document-level state (separate from reading state):

**Store interface:**
```typescript
interface DocumentState {
  // Document info
  filename: string;
  pageCount: number;
  fullText: string;
  outline: TOCItem[];

  // Current section
  currentSection: {
    startPage: number;
    endPage: number;
    text: string;
  } | null;

  // Actions
  setDocument: (filename: string, pageCount: number, fullText: string, outline: TOCItem[]) => void;
  setSection: (startPage: number, endPage: number) => void;
  clearDocument: () => void;
}
```

**Implementation:**
- Use Zustand create() pattern like existing stores
- setDocument: Store all PDF metadata and content
- setSection: Extract text for page range from fullText, store in currentSection
- clearDocument: Reset all fields to initial state
- No persistence needed (single session model per requirements)

**Why separate store:** Document metadata (TOC, page count) is independent from reading state (current word, playback). Separation of concerns enables document navigation without affecting RSVP playback state.

Export as: `export const useDocumentStore = create<DocumentState>(...)`
  </action>
  <verify>Store compiles, can be imported and used in components</verify>
  <done>useDocumentStore provides document state and TOC navigation actions</done>
</task>

<task type="auto">
  <name>Task 4: Create TOC navigation component</name>
  <files>components/pdf/TOCNavigation.tsx</files>
  <action>
Create hierarchical TOC navigation UI:

**Component structure:**
- "use client" directive
- Props: onSectionSelect: (item: TOCItem) => void
- Read outline from useDocumentStore
- Display hierarchical list of TOC items

**UI layout:**
- Use Card component for container
- Title: "Table of Contents" with document filename
- If outline.length === 0: Show "No table of contents available" message with note to use page range selector
- If outline.length > 0: Render hierarchical list

**TOC item rendering:**
- Map over outline items
- Indentation based on item.level (0 = no indent, 1 = 1rem, 2 = 2rem, etc.)
- Clickable button/link with item.title and page number
- onClick: call onSectionSelect(item)
- Hover state with Stone theme accent color
- Current section highlighted (compare with document store current section)

**Styling:**
- Use Stone theme colors for consistency
- Hierarchical indentation using padding-left
- Truncate long titles with ellipsis
- Show page numbers in muted color on right side
- Scrollable list if many items (max-height with overflow-y-auto)

Follow shadcn component patterns. Use lucide-react icons (BookOpen for title, ChevronRight for items).
  </action>
  <verify>Component renders with sample TOC data, items are clickable</verify>
  <done>TOCNavigation displays hierarchical TOC and triggers section selection callback</done>
</task>

<task type="auto">
  <name>Task 5: Create page range selector component</name>
  <files>components/pdf/PageRangeSelector.tsx</files>
  <action>
Create manual page range selection UI for PDFs without TOC:

**Component structure:**
- "use client" directive
- Props: pageCount: number, onRangeSelect: (start: number, end: number) => void
- State: startPage (number), endPage (number), error (string | null)

**UI layout:**
- Use Card component for container
- Title: "Select Page Range"
- Two Input fields (shadcn input component):
  - "From page" (1 to pageCount)
  - "To page" (1 to pageCount)
- Button: "Load Section" (calls onRangeSelect)

**Validation:**
- startPage must be ≥ 1 and ≤ pageCount
- endPage must be ≥ startPage and ≤ pageCount
- Show error message if validation fails
- Disable button until valid range entered

**Default values:**
- startPage = 1
- endPage = Math.min(10, pageCount) (first 10 pages or fewer)

**Styling:**
- Use Label components for input labels
- Stone theme form styling
- Error messages in red below inputs
- Compact layout (inputs side-by-side if space allows)

Install shadcn Input if not already available: `npx shadcn@latest add input`
  </action>
  <verify>Component renders, validates input, calls callback with valid range</verify>
  <done>PageRangeSelector accepts page range input and triggers selection callback</done>
</task>

<task type="auto">
  <name>Task 6: Integrate navigation UI into app</name>
  <files>app/page.tsx</files>
  <action>
Integrate TOC navigation and page range selection into home page flow:

**Add imports:**
```typescript
import { TOCNavigation } from '@/components/pdf/TOCNavigation';
import { PageRangeSelector } from '@/components/pdf/PageRangeSelector';
import { useDocumentStore } from '@/store/document-store';
```

**Update PDF upload completion handler:**
After extractPDF completes:
```typescript
// Store document metadata
useDocumentStore.getState().setDocument(
  result.filename,
  result.pageCount,
  result.text,
  result.outline
);

// Show navigation view (toggle view state)
setView('navigation'); // Add view state: 'upload' | 'navigation' | 'reading'
```

**UI flow with views:**
1. **Upload view:** PDFUpload component (existing)
2. **Navigation view:** Show TOCNavigation OR PageRangeSelector based on outline.length
   - If outline.length > 0: Show TOCNavigation with "Or select pages manually" toggle
   - If outline.length === 0: Show only PageRangeSelector
   - Both: Add "Start Reading Full Document" button to read entire PDF
3. **Reading view:** RSVPDisplay, RSVPControls, SettingsPanel (existing) + "Back to Navigation" button

**Section selection handlers:**
- TOC item click: Extract text for that section (using page ranges), initialize RSVP, switch to reading view
- Page range submit: Extract text for range, initialize RSVP, switch to reading view
- Full document: Use existing full text, initialize RSVP, switch to reading view

**Text extraction by page range:**
For now, use simple approach: Split fullText by newlines, estimate page boundaries. More precise implementation can be refined based on PDF structure.

**Back navigation:**
"Back to Navigation" button in reading view returns to navigation view, preserves document state.

Maintain existing manual text input option alongside PDF workflow. View state management keeps flows independent.
  </action>
  <verify>Complete flow works: upload → see TOC → click section → read → back to TOC</verify>
  <done>User can navigate PDF via TOC or page range, read sections, and return to navigation</done>
</task>

</tasks>

<verification>
**TOC extraction verification:**
Test with PDFs that have structured bookmarks:
- Technical books (O'Reilly, Manning)
- Academic papers with bookmarks
- Verify outline items match PDF bookmarks

Test with PDFs without bookmarks:
- Scanned documents
- Simple reports
- Verify fallback to empty array or heuristic detection

**Navigation flow test:**
1. Upload PDF with TOC (10+ sections)
2. Verify TOC displays hierarchically
3. Click section item
4. Verify RSVP displays section text only (not full document)
5. Click "Back to Navigation"
6. Verify returns to TOC view
7. Select different section
8. Verify RSVP updates with new section text

**Manual page range test:**
1. Upload PDF without TOC
2. Verify PageRangeSelector displays
3. Enter range: pages 5-10
4. Click Load Section
5. Verify RSVP displays text from those pages
6. Test validation: enter invalid ranges (start > end, page > pageCount)
7. Verify error messages display

**Build verification:**
```bash
npm run build
npx tsc --noEmit
```
Both must pass without errors.
</verification>

<success_criteria>
**Measurable completion criteria:**

1. **TOC extraction functional:**
   - PDFs with structured outlines extract hierarchical TOC
   - TOC items show title, page number, and hierarchy level
   - PDFs without outlines return empty array (no crashes)
   - Heuristic detection runs for PDFs without structure

2. **Navigation UI operational:**
   - TOC displays hierarchically with proper indentation
   - TOC items clickable and trigger section load
   - Page range selector validates input
   - Both flows lead to RSVP reading of selected content

3. **Section reading works:**
   - Clicking TOC item loads section text into RSVP
   - Manual page range loads specified pages
   - Reading controls work with section text
   - Back button returns to navigation without losing document state

4. **User experience smooth:**
   - Clear visual distinction between upload, navigation, and reading views
   - Can switch between TOC and page range selection
   - Full document reading remains available as option
   - Navigation state persists during reading session

**Pass criteria:** User uploads PDF, sees TOC or page selector, navigates to specific section, reads with RSVP, and can return to select different section.
</success_criteria>

<output>
After completion, create `.planning/phases/03-pdf-integration/03-03-SUMMARY.md` following established summary format with frontmatter (phase, plan, subsystem: pdf-navigation, tags, dependency graph, tech tracking, key-files, key-decisions, patterns-established, metrics).
</output>
