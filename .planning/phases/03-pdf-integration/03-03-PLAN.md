---
phase: 03-pdf-integration
plan: 03
type: execute
wave: 3
depends_on: [03-01, 03-02]
files_modified:
  - lib/pdf/pdf-extraction-worker.ts
  - lib/pdf/toc-heuristics.ts
  - lib/pdf/section-extractor.ts
  - components/pdf/TOCNavigation.tsx
  - components/pdf/PageRangeSelector.tsx
  - store/document-store.ts
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can see extracted table of contents when PDF has structured outline"
    - "User can navigate to specific sections via TOC"
    - "User can manually select page range when PDF lacks TOC"
    - "User can return to document navigation after reading session"
    - "UI remains responsive during TOC extraction from large PDFs"
  artifacts:
    - path: "lib/pdf/toc-heuristics.ts"
      provides: "Fallback TOC detection via font size and styling heuristics"
      exports: ["detectTOCFromFonts", "extractTableOfContents"]
    - path: "lib/pdf/section-extractor.ts"
      provides: "Extract text content for specific page ranges from parsed PDF pages"
      exports: ["extractSectionText"]
    - path: "components/pdf/TOCNavigation.tsx"
      provides: "Hierarchical TOC display with clickable navigation"
      min_lines: 80
    - path: "components/pdf/PageRangeSelector.tsx"
      provides: "Manual page range selection UI"
      min_lines: 60
    - path: "store/document-store.ts"
      provides: "Document state including TOC and current section"
      exports: ["useDocumentStore"]
  key_links:
    - from: "lib/pdf/pdf-extraction-worker.ts"
      to: "lib/pdf/toc-heuristics.ts"
      via: "call extractTableOfContents with PDF document"
      pattern: "extractTableOfContents\\(pdf\\)"
    - from: "components/pdf/TOCNavigation.tsx"
      to: "store/document-store.ts"
      via: "read TOC items and selected section"
      pattern: "useDocumentStore.*outline"
    - from: "components/pdf/TOCNavigation.tsx"
      to: "lib/pdf/section-extractor.ts"
      via: "extract text for selected TOC section"
      pattern: "extractSectionText"
    - from: "lib/pdf/section-extractor.ts"
      to: "store/reading-store.ts"
      via: "initialize RSVP with selected section text"
      pattern: "readingStore.*initialize"
---

<objective>
Enable navigation through PDF documents via table of contents extraction and manual page selection.

Purpose: Fulfill requirements PDF-03 (extract TOC), PDF-04 (manual page range), PDF-05 (navigate sections), PDF-06 (return to TOC). Long PDFs need structured navigation - users shouldn't read entire document sequentially. TOC extraction leverages structured outlines (~30% of PDFs) with font-based heuristic fallback.

Output: Document navigation UI showing TOC hierarchy, clickable section navigation, and manual page range selection for PDFs without structured outline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-pdf-integration/03-RESEARCH.md

# Prior plans establishing worker and extraction
@.planning/phases/03-pdf-integration/03-01-SUMMARY.md
@.planning/phases/03-pdf-integration/03-02-SUMMARY.md

# Existing stores to understand state patterns
@store/reading-store.ts
@store/settings-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TOC extraction with heuristics</name>
  <files>lib/pdf/toc-heuristics.ts</files>
  <action>
Create TOC extraction module with structured outline parsing and font-based heuristic fallback:

**Import types:**
```typescript
import type { PDFDocumentProxy } from 'pdfjs-dist';
import type { TOCItem } from '@/types/pdf-worker';
```

**Main function:**
```typescript
export async function extractTableOfContents(
  pdf: PDFDocumentProxy
): Promise<TOCItem[]>
```

**Implementation strategy:**
1. Try structured outline first: `const outline = await pdf.getOutline()`
2. If outline exists and has length > 0, call parseOutlineToTOC(pdf, outline)
3. Otherwise, call detectTOCFromFonts(pdf) as fallback
4. Return TOCItem[] (may be empty if no structure detected)

**parseOutlineToTOC helper:**
- Recursive traversal of outline nodes
- For each node:
  - Resolve destination to page index using pdf.getPageIndex()
  - Handle both string destinations (named) and array destinations
  - Extract title from node.title
  - Track hierarchy level (increment on recursion)
- Return flattened TOCItem[] preserving hierarchy via level field
- Follow research pattern for destination resolution (try-catch for failed lookups)

**detectTOCFromFonts helper:**
- Scan first 20 pages (or pdf.numPages if less)
- For each page:
  - Get textContent and calculate average font size
  - Find text items with fontSize > avgSize * 1.3
  - Apply heuristic filters:
    - Length 3-100 characters (not too short, not body text)
    - Contains alphanumeric content
    - Not all uppercase (excludes headers/footers)
- Estimate hierarchy level based on font size ratio (≥2.0 = level 0, ≥1.5 = level 1, else level 2)
- Deduplicate by page+title, sort by page order
- Return TOCItem[]

**Memory management:**
Call page.cleanup() after processing each page in heuristic detection.

Follow research code examples closely - this is a well-defined algorithm.
  </action>
  <verify>Function compiles, can extract TOC from PDF with outline, returns empty array for PDFs without outline</verify>
  <done>extractTableOfContents returns TOCItem[] with title, pageIndex, level for navigation</done>
</task>

<task type="auto">
  <name>Task 2: Update worker to extract TOC</name>
  <files>lib/pdf/pdf-extraction-worker.ts</files>
  <action>
Integrate TOC extraction into worker flow:

**Import toc-heuristics:**
```typescript
import { extractTableOfContents } from './toc-heuristics';
```

**After loading PDF document, before text extraction loop:**
```typescript
const pdf = await loadingTask.promise;

// Extract TOC (runs in worker to keep main thread responsive)
const outline = await extractTableOfContents(pdf);

// (existing text extraction loop follows)
```

**Update complete message:**
Change `outline: []` to `outline` (the extracted TOC).

**Why in worker:** TOC extraction is CPU-intensive (font analysis, page scanning). Running in worker keeps main thread responsive. TOC and text extraction happen in same worker pass for efficiency.

No other changes needed - text extraction loop remains identical.
  </action>
  <verify>Worker returns populated outline field when PDF has TOC structure</verify>
  <done>Worker result includes outline: TOCItem[] with structured navigation data</done>
</task>

<task type="auto">
  <name>Task 3: Create document store for TOC state</name>
  <files>store/document-store.ts</files>
  <action>
Create Zustand store for document-level state (separate from reading state):

**Store interface:**
```typescript
interface DocumentState {
  // Document info
  filename: string;
  pageCount: number;
  fullText: string;
  outline: TOCItem[];

  // Current section
  currentSection: {
    startPage: number;
    endPage: number;
    text: string;
  } | null;

  // Actions
  setDocument: (filename: string, pageCount: number, fullText: string, outline: TOCItem[]) => void;
  setSection: (startPage: number, endPage: number) => void;
  clearDocument: () => void;
}
```

**Implementation:**
- Use Zustand create() pattern like existing stores
- setDocument: Store all PDF metadata and content
- setSection: Extract text for page range from fullText, store in currentSection
- clearDocument: Reset all fields to initial state
- No persistence needed (single session model per requirements)

**Why separate store:** Document metadata (TOC, page count) is independent from reading state (current word, playback). Separation of concerns enables document navigation without affecting RSVP playback state.

Export as: `export const useDocumentStore = create<DocumentState>(...)`
  </action>
  <verify>Store compiles, can be imported and used in components</verify>
  <done>useDocumentStore provides document state and TOC navigation actions</done>
</task>

<task type="auto">
  <name>Task 4: Create section text extraction utility</name>
  <files>lib/pdf/section-extractor.ts</files>
  <action>
Create utility to extract text content for specific page ranges from fullText:

**Export main function:**
```typescript
export function extractSectionText(
  fullText: string,
  startPage: number,
  endPage: number,
  totalPages: number
): string
```

**Algorithm:**
Since worker concatenates page text with newlines (\n), use simple splitting:

1. Split fullText by '\n' to get array of page texts
2. Validate page range (1 ≤ start ≤ end ≤ totalPages)
3. Slice array from (startPage - 1) to endPage (inclusive)
4. Join selected pages back with '\n'
5. Return section text

**Edge cases:**
- If startPage === 1 and endPage === totalPages: return fullText unchanged (optimization)
- If page indices out of bounds: return empty string with console warning
- If split produces fewer items than expected: work with what's available (PDF extraction may have failed pages)

**Why this approach:**
- Worker already extracts text page-by-page with '\n' separators (Plan 03-02)
- Simple string splitting avoids re-parsing PDF
- Fast execution (no async operations)
- Sufficient precision for section reading (exact page boundaries)

Alternative approach (for future optimization): Worker could return Map<pageNum, text> instead of concatenated fullText. Current approach is simpler and sufficient for MVP.
  </action>
  <verify>Function compiles, correctly extracts page ranges from test text</verify>
  <done>extractSectionText returns text content for specified page range</done>
</task>

<task type="auto">
  <name>Task 5: Create TOC navigation component</name>
  <files>components/pdf/TOCNavigation.tsx</files>
  <action>
Create hierarchical TOC navigation UI:

**Component structure:**
- "use client" directive
- Props: onSectionSelect: (item: TOCItem) => void
- Read outline from useDocumentStore
- Display hierarchical list of TOC items

**UI layout:**
- Use Card component for container
- Title: "Table of Contents" with document filename
- If outline.length === 0: Show "No table of contents available" message with note to use page range selector
- If outline.length > 0: Render hierarchical list

**TOC item rendering:**
- Map over outline items
- Indentation based on item.level (0 = no indent, 1 = 1rem, 2 = 2rem, etc.)
- Clickable button/link with item.title and page number
- onClick: call onSectionSelect(item)
- Hover state with Stone theme accent color
- Current section highlighted (compare with document store current section)

**Styling:**
- Use Stone theme colors for consistency
- Hierarchical indentation using padding-left
- Truncate long titles with ellipsis
- Show page numbers in muted color on right side
- Scrollable list if many items (max-height with overflow-y-auto)

Follow shadcn component patterns. Use lucide-react icons (BookOpen for title, ChevronRight for items).
  </action>
  <verify>Component renders with sample TOC data, items are clickable</verify>
  <done>TOCNavigation displays hierarchical TOC and triggers section selection callback</done>
</task>

<task type="auto">
  <name>Task 6: Create page range selector component</name>
  <files>components/pdf/PageRangeSelector.tsx</files>
  <action>
Create manual page range selection UI for PDFs without TOC:

**Component structure:**
- "use client" directive
- Props: pageCount: number, onRangeSelect: (start: number, end: number) => void
- State: startPage (number), endPage (number), error (string | null)

**UI layout:**
- Use Card component for container
- Title: "Select Page Range"
- Two Input fields (shadcn input component):
  - "From page" (1 to pageCount)
  - "To page" (1 to pageCount)
- Button: "Load Section" (calls onRangeSelect)

**Validation:**
- startPage must be ≥ 1 and ≤ pageCount
- endPage must be ≥ startPage and ≤ pageCount
- Show error message if validation fails
- Disable button until valid range entered

**Default values:**
- startPage = 1
- endPage = Math.min(10, pageCount) (first 10 pages or fewer)

**Styling:**
- Use Label components for input labels
- Stone theme form styling
- Error messages in red below inputs
- Compact layout (inputs side-by-side if space allows)

Install shadcn Input if not already available: `npx shadcn@latest add input`
  </action>
  <verify>Component renders, validates input, calls callback with valid range</verify>
  <done>PageRangeSelector accepts page range input and triggers selection callback</done>
</task>

<task type="auto">
  <name>Task 7: Integrate document store wiring in upload handler</name>
  <files>app/page.tsx</files>
  <action>
Integrate document store to receive extracted PDF data from upload handler:

**Verify existing wiring from Plan 03-02 Task 3:**
In the PDF upload completion handler, ensure this pattern exists:
```typescript
import { useDocumentStore } from '@/store/document-store';

// After extraction completes
const result = await processor.extractText(file);

// Store extracted data
useDocumentStore.getState().setDocument(
  result.filename,
  result.pageCount,
  result.text,
  result.outline
);
```

This should already be implemented in Plan 03-02 Task 3. If missing, add it now.

**Why this task:** Checker identified that document store wiring might be missing. This task verifies the connection exists between extraction (03-02) and navigation (03-03).

No additional changes needed if wiring already present from Plan 03-02.
  </action>
  <verify>Document store receives PDF data after upload, outline field populated</verify>
  <done>Upload handler stores extraction result in document store for navigation use</done>
</task>

<task type="auto">
  <name>Task 8: Add navigation view UI</name>
  <files>app/page.tsx</files>
  <action>
Add document navigation view between upload and reading:

**Add imports:**
```typescript
import { TOCNavigation } from '@/components/pdf/TOCNavigation';
import { PageRangeSelector } from '@/components/pdf/PageRangeSelector';
import { useDocumentStore } from '@/store/document-store';
import { extractSectionText } from '@/lib/pdf/section-extractor';
```

**Add view state:**
```typescript
const [view, setView] = useState<'upload' | 'navigation' | 'reading'>('upload');
```

**Update PDF upload completion handler:**
After extraction completes and document store is populated:
```typescript
// Show navigation view
setView('navigation');
```

**Navigation view rendering:**
When view === 'navigation', show:
1. Document info header (filename, page count)
2. If outline.length > 0: TOCNavigation component
3. If outline.length === 0 OR user toggles: PageRangeSelector component
4. "Start Reading Full Document" button (bypasses section selection)

**Section selection handlers:**

**TOC item click:**
```typescript
const handleTOCSelect = (item: TOCItem) => {
  const doc = useDocumentStore.getState();
  // Navigate to section (current item to next item or end)
  const nextItem = outline[outline.indexOf(item) + 1];
  const endPage = nextItem ? nextItem.pageIndex : doc.pageCount;

  const sectionText = extractSectionText(
    doc.fullText,
    item.pageIndex + 1, // pageIndex is 0-based
    endPage,
    doc.pageCount
  );

  // Initialize RSVP with section text
  const groupedWords = groupWords(sectionText, wordsPerGroup);
  useReadingStore.getState().initialize(groupedWords);

  // Store section info
  doc.setSection(item.pageIndex + 1, endPage);

  setView('reading');
};
```

**Page range submit:**
```typescript
const handleRangeSelect = (start: number, end: number) => {
  const doc = useDocumentStore.getState();
  const sectionText = extractSectionText(doc.fullText, start, end, doc.pageCount);

  const groupedWords = groupWords(sectionText, wordsPerGroup);
  useReadingStore.getState().initialize(groupedWords);

  doc.setSection(start, end);

  setView('reading');
};
```

**Full document:**
```typescript
const handleFullDocument = () => {
  const doc = useDocumentStore.getState();
  const groupedWords = groupWords(doc.fullText, wordsPerGroup);
  useReadingStore.getState().initialize(groupedWords);

  doc.setSection(1, doc.pageCount);

  setView('reading');
};
```

Maintain existing manual text input option alongside PDF workflow. View state management keeps flows independent.
  </action>
  <verify>Navigation view displays after upload, TOC items and page range selector work</verify>
  <done>User sees navigation view after PDF upload with TOC or page range options</done>
</task>

<task type="auto">
  <name>Task 9: Add back navigation button</name>
  <files>app/page.tsx</files>
  <action>
Add "Back to Navigation" button in reading view for PDF navigation:

**In reading view (view === 'reading'), add button:**
- Position: Above or below RSVP controls
- Text: "← Back to Navigation"
- Styling: Secondary button style (Stone theme)
- Show only when: document store has a loaded document

**onClick handler:**
```typescript
const handleBackToNavigation = () => {
  const doc = useDocumentStore.getState();

  if (doc.filename) {
    // Pause RSVP playback (preserve current position)
    useReadingStore.getState().pause();

    // Return to navigation view (document state preserved)
    setView('navigation');
  }
};
```

**Reading position preservation (PDF-06 requirement):**
Decision: When user navigates back to TOC, preserve RSVP position within current section.
- On back: Call pause() to stop playback, keep current word index
- If user selects same section again: Resume from preserved position (existing behavior)
- If user selects different section: Reset to beginning of new section (initialize() resets position)

This approach balances requirement PDF-06 (return to TOC) with usability - users can resume where they left off if returning to same section.

**Styling:**
- Use Button component from shadcn
- Place in Card above/below controls
- Add lucide-react ArrowLeft icon
- Muted/secondary appearance (not primary action)

Only show for PDF documents (check if document store has filename). Manual text input flow doesn't need navigation.
  </action>
  <verify>npm run dev, upload PDF, navigate to section, verify back button returns to navigation, RSVP pauses</verify>
  <done>Back button returns user to navigation view, preserves document state, pauses RSVP playback</done>
</task>

</tasks>

<verification>
**TOC extraction verification:**
Test with PDFs that have structured bookmarks:
- Technical books (O'Reilly, Manning)
- Academic papers with bookmarks
- Verify outline items match PDF bookmarks

Test with PDFs without bookmarks:
- Scanned documents
- Simple reports
- Verify fallback to empty array or heuristic detection

**Navigation flow test:**
```bash
npm run dev
```

1. Upload PDF with TOC (10+ sections)
2. Verify TOC displays hierarchically
3. Click TOC item #2
4. Verify RSVP displays section text only (check text length in store matches expected range)
5. Click "Back to Navigation"
6. Verify returns to TOC view
7. Select different section (item #5)
8. Verify RSVP updates with new section text

**Manual page range test:**
1. Upload PDF without TOC
2. Verify PageRangeSelector displays
3. Enter range: pages 5-10
4. Click Load Section
5. Verify RSVP displays text from those pages
6. Test validation: enter invalid ranges (start > end, page > pageCount)
7. Verify error messages display

**Build verification:**
```bash
npm run build
npx tsc --noEmit
```
Both must pass without errors.
</verification>

<success_criteria>
**Measurable completion criteria:**

1. **TOC extraction functional:**
   - PDFs with structured outlines extract hierarchical TOC
   - TOC items show title, page number, and hierarchy level
   - PDFs without outlines return empty array (no crashes)
   - Heuristic detection runs for PDFs without structure

2. **Navigation UI operational:**
   - TOC displays hierarchically with proper indentation
   - TOC items clickable and trigger section load
   - Page range selector validates input
   - Both flows lead to RSVP reading of selected content

3. **Section reading works:**
   - Clicking TOC item loads section text into RSVP
   - Manual page range loads specified pages
   - Reading controls work with section text
   - Back button returns to navigation without losing document state

4. **User experience smooth:**
   - Clear visual distinction between upload, navigation, and reading views
   - Can switch between TOC and page range selection
   - Full document reading remains available as option
   - Navigation state persists during reading session
   - UI remains responsive during TOC extraction

**Pass criteria:** User uploads PDF, sees TOC or page selector, navigates to specific section, reads with RSVP, and can return to select different section.
</success_criteria>

<output>
After completion, create `.planning/phases/03-pdf-integration/03-03-SUMMARY.md` following established summary format with frontmatter (phase, plan, subsystem: pdf-navigation, tags, dependency graph, tech tracking, key-files, key-decisions, patterns-established, metrics).
</output>
