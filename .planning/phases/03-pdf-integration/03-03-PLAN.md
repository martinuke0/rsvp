---
phase: 03-pdf-integration
plan: 03
type: execute
wave: 3
depends_on: [03-01, 03-02]
files_modified:
  - lib/pdf/toc-heuristics.ts
  - lib/pdf/pdf-extraction-worker.ts
  - lib/pdf/section-extractor.ts
  - store/document-store.ts
autonomous: true

must_haves:
  truths:
    - "Worker extracts TOC from PDFs with structured outlines"
    - "Heuristic fallback detects TOC structure from font patterns"
    - "Document store contains extracted PDF metadata and TOC"
    - "Section extraction utility can isolate page ranges from full text"
  artifacts:
    - path: "lib/pdf/toc-heuristics.ts"
      provides: "Fallback TOC detection via font size and styling heuristics"
      exports: ["detectTOCFromFonts", "extractTableOfContents"]
    - path: "lib/pdf/pdf-extraction-worker.ts"
      provides: "Worker with integrated TOC extraction"
      contains: "extractTableOfContents"
    - path: "lib/pdf/section-extractor.ts"
      provides: "Extract text content for specific page ranges from parsed PDF pages"
      exports: ["extractSectionText"]
    - path: "store/document-store.ts"
      provides: "Document state including TOC and current section"
      exports: ["useDocumentStore"]
  key_links:
    - from: "lib/pdf/pdf-extraction-worker.ts"
      to: "lib/pdf/toc-heuristics.ts"
      via: "call extractTableOfContents with PDF document"
      pattern: "extractTableOfContents\\(pdf\\)"
    - from: "store/document-store.ts"
      to: "types/pdf-worker.ts"
      via: "import TOCItem type for outline storage"
      pattern: "import.*TOCItem"
---

<objective>
Implement TOC extraction logic and document state management for PDF navigation.

Purpose: Establish the data layer for document navigation. TOC extraction (~30% structured outlines + font-based heuristic fallback) and document store enable subsequent navigation UI (Plan 03-04). Separating extraction logic from UI components keeps context budget under control and allows parallel development.

Output: Working TOC extraction in worker thread, document store with PDF metadata, and section text extraction utility ready for UI consumption.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-pdf-integration/03-RESEARCH.md

# Prior plans establishing worker and extraction
@.planning/phases/03-pdf-integration/03-01-SUMMARY.md
@.planning/phases/03-pdf-integration/03-02-SUMMARY.md

# Existing stores to understand state patterns
@store/reading-store.ts
@store/settings-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TOC extraction with heuristics</name>
  <files>lib/pdf/toc-heuristics.ts</files>
  <action>
Create TOC extraction module with structured outline parsing and font-based heuristic fallback:

**Import types:**
```typescript
import type { PDFDocumentProxy } from 'pdfjs-dist';
import type { TOCItem } from '@/types/pdf-worker';
```

**Main function:**
```typescript
export async function extractTableOfContents(
  pdf: PDFDocumentProxy
): Promise<TOCItem[]>
```

**Implementation strategy:**
1. Try structured outline first: `const outline = await pdf.getOutline()`
2. If outline exists and has length > 0, call parseOutlineToTOC(pdf, outline)
3. Otherwise, call detectTOCFromFonts(pdf) as fallback
4. Return TOCItem[] (may be empty if no structure detected)

**parseOutlineToTOC helper:**
- Recursive traversal of outline nodes
- For each node:
  - Resolve destination to page index using pdf.getPageIndex()
  - Handle both string destinations (named) and array destinations
  - Extract title from node.title
  - Track hierarchy level (increment on recursion)
- Return flattened TOCItem[] preserving hierarchy via level field
- Follow research pattern for destination resolution (try-catch for failed lookups)

**detectTOCFromFonts helper:**
- Scan first 20 pages (or pdf.numPages if less)
- For each page:
  - Get textContent and calculate average font size
  - Find text items with fontSize > avgSize * 1.3
  - Apply heuristic filters:
    - Length 3-100 characters (not too short, not body text)
    - Contains alphanumeric content
    - Not all uppercase (excludes headers/footers)
- Estimate hierarchy level based on font size ratio (≥2.0 = level 0, ≥1.5 = level 1, else level 2)
- Deduplicate by page+title, sort by page order
- Return TOCItem[]

**Memory management:**
Call page.cleanup() after processing each page in heuristic detection.

Follow research code examples closely - this is a well-defined algorithm.
  </action>
  <verify>Function compiles, can extract TOC from PDF with outline, returns empty array for PDFs without outline</verify>
  <done>extractTableOfContents returns TOCItem[] with title, pageIndex, level for navigation</done>
</task>

<task type="auto">
  <name>Task 2: Update worker to extract TOC</name>
  <files>lib/pdf/pdf-extraction-worker.ts</files>
  <action>
Integrate TOC extraction into worker flow:

**Import toc-heuristics:**
```typescript
import { extractTableOfContents } from './toc-heuristics';
```

**After loading PDF document, before text extraction loop:**
```typescript
const pdf = await loadingTask.promise;

// Extract TOC (runs in worker to keep main thread responsive)
const outline = await extractTableOfContents(pdf);

// (existing text extraction loop follows)
```

**Update complete message:**
Change `outline: []` to `outline` (the extracted TOC).

**Why in worker:** TOC extraction is CPU-intensive (font analysis, page scanning). Running in worker keeps main thread responsive. TOC and text extraction happen in same worker pass for efficiency.

No other changes needed - text extraction loop remains identical.
  </action>
  <verify>Worker returns populated outline field when PDF has TOC structure</verify>
  <done>Worker result includes outline: TOCItem[] with structured navigation data</done>
</task>

<task type="auto">
  <name>Task 3: Create document store for TOC state</name>
  <files>store/document-store.ts</files>
  <action>
Create Zustand store for document-level state (separate from reading state):

**Store interface:**
```typescript
interface DocumentState {
  // Document info
  filename: string;
  pageCount: number;
  fullText: string;
  outline: TOCItem[];

  // Current section
  currentSection: {
    startPage: number;
    endPage: number;
    text: string;
  } | null;

  // Actions
  setDocument: (filename: string, pageCount: number, fullText: string, outline: TOCItem[]) => void;
  setSection: (startPage: number, endPage: number) => void;
  clearDocument: () => void;
}
```

**Implementation:**
- Use Zustand create() pattern like existing stores
- setDocument: Store all PDF metadata and content
- setSection: Extract text for page range from fullText, store in currentSection
- clearDocument: Reset all fields to initial state
- No persistence needed (single session model per requirements)

**Why separate store:** Document metadata (TOC, page count) is independent from reading state (current word, playback). Separation of concerns enables document navigation without affecting RSVP playback state.

Export as: `export const useDocumentStore = create<DocumentState>(...)`
  </action>
  <verify>Store compiles, can be imported and used in components</verify>
  <done>useDocumentStore provides document state and TOC navigation actions</done>
</task>

<task type="auto">
  <name>Task 4: Create section text extraction utility</name>
  <files>lib/pdf/section-extractor.ts</files>
  <action>
Create utility to extract text content for specific page ranges from fullText:

**Export main function:**
```typescript
export function extractSectionText(
  fullText: string,
  startPage: number,
  endPage: number,
  totalPages: number
): string
```

**Algorithm:**
Since worker concatenates page text with newlines (\n), use simple splitting:

1. Split fullText by '\n' to get array of page texts
2. Validate page range (1 ≤ start ≤ end ≤ totalPages)
3. Slice array from (startPage - 1) to endPage (inclusive)
4. Join selected pages back with '\n'
5. Return section text

**Edge cases:**
- If startPage === 1 and endPage === totalPages: return fullText unchanged (optimization)
- If page indices out of bounds: return empty string with console warning
- If split produces fewer items than expected: work with what's available (PDF extraction may have failed pages)

**Why this approach:**
- Worker already extracts text page-by-page with '\n' separators (Plan 03-02)
- Simple string splitting avoids re-parsing PDF
- Fast execution (no async operations)
- Sufficient precision for section reading (exact page boundaries)

Alternative approach (for future optimization): Worker could return Map<pageNum, text> instead of concatenated fullText. Current approach is simpler and sufficient for MVP.
  </action>
  <verify>Function compiles, correctly extracts page ranges from test text</verify>
  <done>extractSectionText returns text content for specified page range</done>
</task>

</tasks>

<verification>
**TOC extraction verification:**
Test with PDFs that have structured bookmarks:
- Technical books (O'Reilly, Manning)
- Academic papers with bookmarks
- Verify outline items match PDF bookmarks

Test with PDFs without bookmarks:
- Scanned documents
- Simple reports
- Verify fallback to empty array or heuristic detection

**Store verification:**
```bash
# Verify document store compiles
npx tsc --noEmit
```

**Unit test section extractor:**
Create test text with page separators:
```typescript
const testText = "Page 1\nPage 2\nPage 3\nPage 4\nPage 5";
const section = extractSectionText(testText, 2, 4, 5);
// Should return: "Page 2\nPage 3\nPage 4"
```

**Build verification:**
```bash
npm run build
```
Must complete without errors.
</verification>

<success_criteria>
**Measurable completion criteria:**

1. **TOC extraction functional:**
   - PDFs with structured outlines extract hierarchical TOC
   - TOC items show title, page number, and hierarchy level
   - PDFs without outlines return empty array (no crashes)
   - Heuristic detection runs for PDFs without structure

2. **Document store operational:**
   - Store compiles and exports useDocumentStore hook
   - setDocument stores PDF metadata and TOC
   - setSection calculates and stores section boundaries
   - clearDocument resets all state

3. **Section extraction working:**
   - extractSectionText correctly isolates page ranges
   - Handles edge cases (full document, invalid ranges)
   - Fast execution (synchronous string operations)

4. **Production-ready:**
   - TypeScript compilation passes
   - Build succeeds without warnings
   - Worker returns populated outline field
   - All utilities have proper TypeScript types

**Pass criteria:** Worker extracts TOC and returns structured outline, document store holds PDF metadata, section extractor isolates page ranges correctly.
</success_criteria>

<output>
After completion, create `.planning/phases/03-pdf-integration/03-03-SUMMARY.md` following established summary format with frontmatter (phase, plan, subsystem: pdf-navigation, tags, dependency graph, tech tracking, key-files, key-decisions, patterns-established, metrics).
</output>
