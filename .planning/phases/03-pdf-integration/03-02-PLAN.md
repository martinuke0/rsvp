---
phase: 03-pdf-integration
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - lib/pdf/pdf-extraction-worker.ts
  - hooks/use-pdf-extraction.ts
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can upload PDF and extracted text loads into RSVP reader"
    - "PDF text extraction completes in under 5 seconds for typical PDFs"
    - "User can start reading immediately after extraction completes"
  artifacts:
    - path: "lib/pdf/pdf-extraction-worker.ts"
      provides: "Full text extraction with lazy page loading and memory cleanup"
      contains: "page.cleanup()"
    - path: "hooks/use-pdf-extraction.ts"
      provides: "React hook managing extraction state and RSVP integration"
      exports: ["usePDFExtraction"]
    - path: "app/page.tsx"
      provides: "Integrated UI with PDF upload and RSVP reading"
      contains: "PDFUpload"
  key_links:
    - from: "hooks/use-pdf-extraction.ts"
      to: "lib/pdf/pdf-processor.ts"
      via: "call extractText method"
      pattern: "processor\\.extractText"
    - from: "hooks/use-pdf-extraction.ts"
      to: "lib/rsvp/word-grouper.ts"
      via: "group extracted text into word chunks"
      pattern: "groupWords\\(.*text"
    - from: "hooks/use-pdf-extraction.ts"
      to: "store/reading-store.ts"
      via: "initialize RSVP store with grouped words"
      pattern: "readingStore.*initialize"
---

<objective>
Implement full PDF text extraction with lazy page loading and integrate with existing RSVP engine.

Purpose: Enable users to read PDF content with RSVP display. This completes the critical path: PDF upload → text extraction → word grouping → RSVP reading. Memory-efficient extraction prevents browser crashes with 50MB files.

Output: Working end-to-end flow where user uploads PDF, sees extraction progress, and can immediately start RSVP reading of PDF text content.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-pdf-integration/03-RESEARCH.md

# Prior plan establishing worker infrastructure
@.planning/phases/03-pdf-integration/03-01-SUMMARY.md

# Existing RSVP engine to integrate with
@.planning/phases/02-core-rsvp-engine/02-01-SUMMARY.md
@.planning/phases/02-core-rsvp-engine/02-02-SUMMARY.md
@lib/rsvp/word-grouper.ts
@store/reading-store.ts
@store/settings-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement lazy page loading in worker</name>
  <files>lib/pdf/pdf-extraction-worker.ts</files>
  <action>
Extend worker to extract text from all pages with memory-efficient lazy loading:

**After loading PDF document (existing code):**
```typescript
const pdf = await loadingTask.promise;
const totalPages = pdf.numPages;
```

**Add text extraction loop:**
```typescript
let fullText = '';

for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
  // Load page
  const page = await pdf.getPage(pageNum);

  // Extract text content
  const textContent = await page.getTextContent();

  // Combine text items with spaces
  const pageText = textContent.items
    .map((item: any) => item.str)
    .join(' ');

  fullText += pageText + '\n';

  // CRITICAL: Release page memory immediately
  page.cleanup();

  // Report progress (pageNum / totalPages * 100)
  self.postMessage({
    type: 'progress',
    progress: (pageNum / totalPages) * 100
  });
}
```

**Update complete message:**
Change `text: ''` to `text: fullText` in the complete response.

**Why this pattern:** Sequential page loading with immediate cleanup prevents memory accumulation. Research shows this is essential for 50MB file support. Progress reporting at page boundaries provides natural feedback points.

Keep outline extraction as empty array for now (Plan 03-03 will implement).
  </action>
  <verify>Worker extracts text from multi-page PDF, progress updates incrementally, memory usage stays bounded</verify>
  <done>Worker returns full PDF text in result.text field, page.cleanup() called after each page</done>
</task>

<task type="auto">
  <name>Task 2: Create PDF extraction React hook</name>
  <files>hooks/use-pdf-extraction.ts</files>
  <action>
Create React hook that orchestrates PDF extraction and RSVP integration:

**Hook interface:**
```typescript
interface UsePDFExtractionResult {
  isExtracting: boolean;
  progress: number;
  error: string | null;
  extractPDF: (file: File, wordsPerGroup: number) => Promise<void>;
  cancel: () => void;
}

export function usePDFExtraction(): UsePDFExtractionResult
```

**State management:**
- useState for isExtracting, progress, error
- useState for processor instance
- Import useReadingStore, useSettingsStore from existing stores

**extractPDF implementation:**
1. Set isExtracting=true, progress=0, error=null
2. Create PDFProcessor with onProgress callback: (p) => setProgress(p)
3. await processor.extractText(file)
4. Call groupWords(result.text, wordsPerGroup) from lib/rsvp/word-grouper.ts
5. Call useReadingStore.getState().initialize(groupedWords)
6. Set isExtracting=false
7. Wrap in try-catch: on error, set error state with message

**cancel implementation:**
- Call processor.cancel()
- Reset isExtracting, progress to initial state

**Use useCallback for extractPDF and cancel** with proper dependency arrays to prevent stale closures (learned from Phase 2 bug fix).

Import types from types/pdf-worker.ts. Import PDFProcessor from lib/pdf/pdf-processor.ts. Import groupWords from lib/rsvp/word-grouper.ts. Import useReadingStore from store/reading-store.ts.
  </action>
  <verify>Hook compiles without TypeScript errors, can be imported in components</verify>
  <done>usePDFExtraction hook exports extractPDF function that chains extraction → grouping → RSVP initialization</done>
</task>

<task type="auto">
  <name>Task 3: Integrate PDF upload into home page</name>
  <files>app/page.tsx</files>
  <action>
Integrate PDF upload with existing RSVP UI, replacing manual text input with PDF upload option:

**Add to imports:**
```typescript
import { PDFUpload } from '@/components/pdf/PDFUpload';
import { usePDFExtraction } from '@/hooks/use-pdf-extraction';
```

**Hook usage:**
```typescript
const { isExtracting, progress, error, extractPDF } = usePDFExtraction();
const wordsPerGroup = useSettingsStore((state) => state.wordsPerGroup);
```

**UI structure modification:**
Replace or add alongside existing textarea input:

**Option A (Replace textarea with PDF upload):**
- Remove existing textarea and Load Text button
- Add PDFUpload component with onUploadComplete callback
- Callback: await extractPDF(file, wordsPerGroup)
- Keep Reset button for starting over

**Option B (Add PDF upload above textarea):**
- Keep existing textarea for manual text input
- Add PDFUpload above textarea with "or" separator
- Both flows lead to RSVP display
- User can switch between PDF and manual text

**Choose Option B** - more flexible, preserves existing functionality, allows testing both input methods.

**Error display:**
If error state from usePDFExtraction, show error message above components using Alert component (install with shadcn if needed, or use simple div with text-red-500).

**Loading state:**
When isExtracting=true, show progress value and disable controls.

Follow existing patterns: client component with "use client", Card layout, Stone theme styling. Maintain vertical spacing and centered layout from current design.
  </action>
  <verify>Page renders with PDF upload option, can upload PDF and see RSVP display populate</verify>
  <done>User can upload PDF, see extraction progress, and RSVP display shows PDF text</done>
</task>

</tasks>

<verification>
**End-to-end flow test:**
1. Start dev server: `npm run dev`
2. Open browser to localhost:3000
3. Drag a multi-page PDF (10+ pages) to upload area
4. Verify progress bar updates from 0% to 100%
5. Verify RSVP display shows PDF text
6. Click Play button and verify words display
7. Check browser DevTools Performance tab - no long tasks on main thread during extraction

**Memory verification:**
1. Open DevTools Memory profiler
2. Upload 20-30MB PDF
3. Take heap snapshot after extraction completes
4. Verify memory usage returns to baseline after extraction
5. No "detached DOM nodes" or leaked page objects

**Error handling verification:**
```bash
# Test file size limit
dd if=/dev/zero of=/tmp/large.pdf bs=1m count=51
```
Upload should show "exceeds 50MB limit" error message.

**TypeScript verification:**
```bash
npx tsc --noEmit
```
Must pass with no errors.

**Build verification:**
```bash
npm run build
```
Must complete without errors or warnings.
</verification>

<success_criteria>
**Measurable completion criteria:**

1. **Text extraction functional:**
   - Multi-page PDFs extract all text content
   - Progress updates incrementally (not just 0% → 100%)
   - Extraction completes in under 5 seconds for typical PDFs (<5MB)
   - Memory usage bounded (no crashes on 50MB files)

2. **RSVP integration working:**
   - Extracted text populates word grouping
   - RSVP display shows PDF words with ORP highlighting
   - Play/pause controls work with PDF text
   - Settings (WPM, word grouping) apply to PDF text

3. **User experience smooth:**
   - No UI freezing during extraction
   - Progress bar updates smoothly
   - Error messages clear and actionable
   - Can switch between PDF and manual text input

4. **Production-ready:**
   - TypeScript compilation passes
   - Build succeeds without warnings
   - All existing functionality (manual text input) still works
   - No console errors in browser DevTools

**Pass criteria:** User uploads PDF, sees smooth progress, and can immediately start RSVP reading with all existing controls functional.
</success_criteria>

<output>
After completion, create `.planning/phases/03-pdf-integration/03-02-SUMMARY.md` following established summary format with frontmatter (phase, plan, subsystem: pdf-integration, tags, dependency graph, tech tracking, key-files, key-decisions, patterns-established, metrics).
</output>
