---
phase: 04-controls-and-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - store/reading-store.ts
  - components/reader/RSVPControls.tsx
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "User sees visual progress bar showing position in current section"
    - "User sees time estimate showing remaining reading time"
    - "User's reading position persists when pausing mid-section"
    - "User's reading position restores when returning to same document section"
    - "Position does NOT restore when loading different document or section"
  artifacts:
    - path: "store/reading-store.ts"
      provides: "Zustand persist middleware with savedPosition state"
      contains: "persist("
      exports: ["useReadingStore"]
    - path: "components/reader/RSVPControls.tsx"
      provides: "Progress bar UI with time estimation"
      contains: "Progress"
      min_lines: 80
    - path: "app/page.tsx"
      provides: "Position auto-save on pause and resume on section load"
      contains: "savePosition"
  key_links:
    - from: "components/reader/RSVPControls.tsx"
      to: "Progress component"
      via: "progress value subscription"
      pattern: "Progress.*value=\\{progress\\}"
    - from: "app/page.tsx"
      to: "reading-store.savePosition"
      via: "pause handler"
      pattern: "setIsPlaying\\(false\\).*savePosition"
    - from: "reading-store.restorePosition"
      to: "document-store state"
      via: "composite key matching"
      pattern: "filename.*sectionStart.*sectionEnd"
---

<objective>
Add position persistence and visual progress tracking to enable session continuity and reading progress awareness - users can pause mid-section and resume from exact position, with visual feedback showing completion percentage and remaining time.

Purpose: Essential for long-form reading - users need progress awareness for time estimation and position persistence for session interruption without losing place in 50+ page documents.

Output: Visual progress bar with time estimate, reading position persistence across browser sessions, automatic position save/restore with composite key matching (filename + section range).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-controls-and-polish/04-RESEARCH.md

# Current implementation
@store/reading-store.ts
@store/settings-store.ts
@store/document-store.ts
@components/reader/RSVPControls.tsx
@app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add position persistence to reading store</name>
  <files>store/reading-store.ts</files>
  <action>
Extend reading store with Zustand persist middleware for position persistence:

1. Import persist middleware:
```typescript
import { persist } from 'zustand/middleware';
```

2. Add SavedPosition interface before ReadingState:
```typescript
interface SavedPosition {
  filename: string;
  sectionStart: number;
  sectionEnd: number;
  wordIndex: number;
  timestamp: number;
}
```

3. Add to ReadingState interface:
```typescript
savedPosition: SavedPosition | null;
savePosition: (filename: string, section: { startPage: number; endPage: number }) => void;
restorePosition: () => number | null;
```

4. Wrap store creation with persist middleware (pattern from settings-store.ts):
```typescript
export const useReadingStore = create<ReadingState>()(
  persist(
    (set, get) => ({
      // ... existing state ...
      savedPosition: null,

      savePosition: (filename, section) => {
        set({
          savedPosition: {
            filename,
            sectionStart: section.startPage,
            sectionEnd: section.endPage,
            wordIndex: get().currentIndex,
            timestamp: Date.now(),
          }
        });
      },

      restorePosition: () => {
        const saved = get().savedPosition;
        if (!saved) return null;

        // Import document store to check current document
        const doc = useDocumentStore.getState();

        // Composite key match: same filename + same section range
        if (saved.filename === doc.filename &&
            saved.sectionStart === doc.currentSection?.startPage &&
            saved.sectionEnd === doc.currentSection?.endPage) {
          return saved.wordIndex;
        }

        return null; // No match - different document or section
      },
    }),
    {
      name: 'rsvp-reading-position',
      // CRITICAL: Only persist savedPosition, not runtime state
      partialize: (state) => ({
        savedPosition: state.savedPosition,
      }),
    }
  )
);
```

CRITICAL NOTES:
- partialize ensures only savedPosition persists (not currentWord, isPlaying, etc.)
- Composite key matching prevents position restore from wrong document/section
- Import useDocumentStore inside restorePosition function (not at file top - circular dependency risk)
- timestamp useful for future "continue where you left off" UI
  </action>
  <verify>
1. Build succeeds: `npm run build`
2. TypeScript compilation passes (no circular dependency errors)
3. Check localStorage in browser DevTools:
   - Load text, play to word 50, pause
   - Check Application tab → Local Storage → rsvp-reading-position
   - Should contain savedPosition with wordIndex: 50
  </verify>
  <done>
- Reading store wrapped with persist middleware
- SavedPosition interface defined
- savePosition action stores composite key (filename + section + wordIndex)
- restorePosition returns wordIndex only if composite key matches
- partialize limits persistence to savedPosition field only
- Build passes without circular dependency errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add visual progress bar with time estimate</name>
  <files>components/reader/RSVPControls.tsx</files>
  <action>
Enhance RSVPControls with visual progress bar and time estimate:

1. Import Progress component (already in project):
```typescript
import { Progress } from '@/components/ui/progress';
```

2. Import useSettingsStore to get WPM for time calculation:
```typescript
import { useSettingsStore } from '@/store/settings-store';
```

3. Add wpm subscription after existing subscriptions:
```typescript
const wpm = useSettingsStore((state) => state.wpm);
```

4. Add time calculation after existing progress calculation:
```typescript
// Calculate remaining time
const remainingWords = totalWords - currentIndex;
const remainingSeconds = Math.ceil((remainingWords / wpm) * 60);

const formatTime = (seconds: number): string => {
  if (seconds < 60) return `${seconds}s`;
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
};
```

5. Replace existing progress text with Progress bar component:
```tsx
{/* Visual Progress Bar + Time */}
{totalWords > 0 && (
  <div className="w-full max-w-md space-y-2">
    <Progress value={progress} className="h-2" />
    <div className="flex justify-between text-sm text-muted-foreground">
      <span>Word {currentIndex + 1} of {totalWords}</span>
      <span>{formatTime(remainingSeconds)} remaining</span>
    </div>
  </div>
)}
```

Layout: Place after Play/Pause button, before restart button (if exists from 04-01).
  </action>
  <verify>
1. Build succeeds: `npm run build`
2. Visual verification:
   - Load sample text
   - Click Play
   - Progress bar should animate smoothly from 0% to 100%
   - Left text shows "Word X of Y"
   - Right text shows remaining time (e.g., "1:23" or "45s")
3. Time calculation accuracy:
   - Load text with 300 words at 300 WPM
   - Should show approximately 1:00 remaining at start
   - As reading progresses, time should decrease
  </verify>
  <done>
- Progress bar displays with smooth animation
- Progress value correctly calculated (currentIndex / totalWords * 100)
- Time estimate displays remaining time based on WPM
- Time formatting: M:SS for ≥60s, Xs for <60s
- Word count shows "Word X of Y" on left
- Build passes TypeScript compilation
  </done>
</task>

<task type="auto">
  <name>Task 3: Add position auto-save and restore</name>
  <files>app/page.tsx</files>
  <action>
Integrate position save/restore into reading flow:

1. Add auto-save on pause:
   - Find existing handleBackToNavigation function (created in Phase 3)
   - Before `setIsPlaying(false)`, add position save:
```typescript
// Save position before pausing
const doc = useDocumentStore.getState();
if (doc.filename && doc.currentSection) {
  useReadingStore.getState().savePosition(doc.filename, doc.currentSection);
}
```

2. Add restore on section load:
   - Find handleTOCSelect function
   - After `initialize(groupedWords)` call, add restore logic:
```typescript
// Check for saved position
const savedIndex = useReadingStore.getState().restorePosition();
if (savedIndex !== null && savedIndex < groupedWords.length) {
  // Restore position
  useReadingStore.getState().setCurrentWord(groupedWords[savedIndex], savedIndex);
}
```

3. Add same restore logic to handleRangeSelect function (duplicate pattern)

4. Add same restore logic to handleFullDocumentRead function (if exists)

5. Add periodic auto-save during playback:
   - Add useEffect hook:
```typescript
useEffect(() => {
  const reading = useReadingStore.getState();
  const doc = useDocumentStore.getState();

  // Only save if actively reading a document section
  if (reading.isPlaying && doc.filename && doc.currentSection) {
    // Auto-save every 5 seconds during playback
    const interval = setInterval(() => {
      const currentReading = useReadingStore.getState();
      const currentDoc = useDocumentStore.getState();
      if (currentReading.isPlaying && currentDoc.filename && currentDoc.currentSection) {
        currentReading.savePosition(currentDoc.filename, currentDoc.currentSection);
      }
    }, 5000);

    return () => clearInterval(interval);
  }
}, [/* reading.isPlaying - get from subscription if needed */]);
```

CRITICAL NOTES:
- Restore happens AFTER initialize (so words array exists)
- Restore checks savedIndex < groupedWords.length (boundary validation)
- Periodic save prevents loss on browser crash
- Composite key matching happens in store.restorePosition()
  </action>
  <verify>
1. Build succeeds: `npm run build`
2. Position save on pause:
   - Load PDF, select section, play to word 50, press Escape (pause + back)
   - Check localStorage → rsvp-reading-position
   - Should contain wordIndex: 50
3. Position restore on section load:
   - Without reloading page, select same section again
   - Should resume from word 50 (not word 1)
4. Position NOT restored for different section:
   - Select different section from TOC
   - Should start from word 1 (not preserved position)
5. Position restored after browser refresh:
   - Load PDF, select section, play to word 50, pause
   - Refresh browser (F5)
   - Select same section again
   - Should resume from word 50
6. Periodic auto-save:
   - Load section, play for 10 seconds
   - Check localStorage - should update multiple times during playback
  </verify>
  <done>
- Position saves on pause/back navigation
- Position saves periodically every 5 seconds during playback
- Position restores when loading same document + section
- Position does NOT restore when loading different document or section
- Restore validation prevents array out-of-bounds errors
- Build passes TypeScript compilation
  </done>
</task>

</tasks>

<verification>
Run comprehensive verification sequence:

1. **Progress bar displays correctly:**
```bash
npm run build && npm run dev
```
- Load sample text
- Progress bar should show 0%, animate to 100% during reading
- Time estimate should decrease as reading progresses

2. **Position persistence works:**
- Load PDF with multiple sections
- Select section A, read to word 50, pause, press Escape
- Select section A again → should resume from word 50
- Select section B → should start from word 1 (different section)
- Refresh browser, select section A again → should resume from word 50

3. **Periodic auto-save works:**
- Load section, play for 10+ seconds without pausing
- Open DevTools → Application → Local Storage
- Watch rsvp-reading-position update every 5 seconds

4. **TypeScript compilation:**
```bash
npm run build
```
Should complete without errors.

5. **Edge cases:**
- Load manual text (no filename) → position save should not error (handle null filename)
- Load section with <5 words → restore should not cause out-of-bounds error
</verification>

<success_criteria>
**Observable behaviors:**
- Progress bar displays and animates smoothly during reading
- Time estimate shows remaining time in M:SS or Xs format
- Word count displays "Word X of Y" alongside progress bar
- Reading position persists when pausing mid-section
- Position restores when returning to same document + section
- Position does NOT restore when switching documents or sections

**Technical correctness:**
- Zustand persist middleware wraps reading store correctly
- partialize limits persistence to savedPosition field only
- Composite key matching (filename + section) prevents wrong position restore
- Boundary validation prevents array out-of-bounds on restore
- Periodic save uses setInterval with proper cleanup

**Requirements fulfilled:**
- CTRL-05: System persists reading position across browser sessions ✓
- CTRL-06: System displays progress bar showing position in current section ✓
- UI-03: System persists user settings across sessions ✓ (via settings-store from Phase 2)
</success_criteria>

<output>
After completion, create `.planning/phases/04-controls-and-polish/04-02-SUMMARY.md` with:
- Performance metrics (duration, tasks completed)
- Files modified (reading-store.ts, RSVPControls.tsx, page.tsx)
- Progress bar implementation details
- Position persistence verification results
- Composite key matching validation
- Any deviations from plan
- Phase 4 completion status (all requirements fulfilled)
</output>
