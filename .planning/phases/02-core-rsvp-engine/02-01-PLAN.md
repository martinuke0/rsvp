---
phase: 02-core-rsvp-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - lib/rsvp/engine.ts
  - lib/rsvp/orp-calculator.ts
  - lib/rsvp/word-grouper.ts
  - store/reading-store.ts
  - store/settings-store.ts
autonomous: true

must_haves:
  truths:
    - "RAF timing loop calculates word position from elapsed time (no drift)"
    - "ORP calculation places center letter at 30-40% from word start"
    - "Word grouping creates fixed-size chunks without losing text"
    - "Zustand stores provide state without re-render jank"
    - "Settings persist across browser sessions"
  artifacts:
    - path: "lib/rsvp/engine.ts"
      provides: "RAF timing loop with pause/resume"
      exports: ["RSVPEngine"]
      min_lines: 80
    - path: "lib/rsvp/orp-calculator.ts"
      provides: "ORP calculation and text splitting"
      exports: ["calculateORP", "splitAtORP"]
      min_lines: 60
    - path: "lib/rsvp/word-grouper.ts"
      provides: "Word grouping logic"
      exports: ["groupWords"]
      min_lines: 20
    - path: "store/reading-store.ts"
      provides: "Reading state management"
      exports: ["useReadingStore"]
      min_lines: 40
    - path: "store/settings-store.ts"
      provides: "Settings with persistence"
      exports: ["useSettingsStore"]
      min_lines: 30
  key_links:
    - from: "lib/rsvp/engine.ts"
      to: "timestamp-based positioning"
      via: "Math.floor(elapsed / msPerWord)"
      pattern: "Math\\.floor.*elapsed.*msPerWord"
    - from: "lib/rsvp/orp-calculator.ts"
      to: "length-based ORP ratio"
      via: "30-40% calculation"
      pattern: "0\\.(3[0-5]|[3-4][0-9])"
    - from: "store/settings-store.ts"
      to: "zustand persist middleware"
      via: "persist wrapper"
      pattern: "persist\\("
---

<objective>
Create the foundational RSVP engine with RAF-based timing, ORP calculation, word grouping, and Zustand state management.

Purpose: Establish the architectural foundations that cannot be retrofitted later - RAF timing prevents drift, ORP calculation trains user eye movements correctly from day one, Zustand prevents re-render jank at high WPM.

Output: Core engine modules and state stores ready for React component integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-rsvp-engine/02-RESEARCH.md
@.planning/phases/01-project-foundation/01-01-SUMMARY.md
@.planning/phases/01-project-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies</name>
  <files>package.json</files>
  <action>
Install Zustand for state management and use-debounce for slider optimization:

```bash
npm install zustand@5.0.10 use-debounce@10.1.0
```

These exact versions are from RESEARCH.md verification:
- zustand@5.0.10: Selective subscriptions prevent re-render jank at high WPM
- use-debounce@10.1.0: Debounce WPM slider changes during drag

clsx and tailwind-merge already installed in Phase 01-01.
  </action>
  <verify>
```bash
grep "zustand" package.json
grep "use-debounce" package.json
npm ls zustand use-debounce
```
  </verify>
  <done>package.json contains zustand@5.0.10 and use-debounce@10.1.0, npm ls confirms installation</done>
</task>

<task type="auto">
  <name>Task 2: Create RAF-based timing engine</name>
  <files>lib/rsvp/engine.ts</files>
  <action>
Create RSVPEngine class using requestAnimationFrame with timestamp-based positioning. This is CRITICAL and cannot be retrofitted - timing precision is foundational.

Implementation requirements from RESEARCH.md Pattern 1:

**MUST use timestamp-based positioning:**
```typescript
const targetIndex = pausedWordIndex + Math.floor(elapsed / msPerWord);
```
NOT iteration-based incrementing (causes drift).

**MUST handle pause/resume correctly:**
- Store pausedWordIndex and pausedAt timestamp
- Recalculate startTime on resume accounting for pause duration
- Use cancelAnimationFrame on pause

**Class structure:**
```typescript
export class RSVPEngine {
  private rafId: number | null = null;
  private startTime: number = 0;
  private pausedAt: number = 0;
  private pausedWordIndex: number = 0;
  private isRunning: boolean = false;

  start(
    words: string[],
    wpm: number,
    startIndex: number,
    onWordChange: (word: string, index: number) => void
  ): void;

  pause(): number;
  destroy(): void;
}
```

**Critical implementation details:**
1. Calculate `msPerWord = 60000 / wpm` inside loop
2. Initialize `startTime = timestamp` on first frame
3. Calculate `elapsed = timestamp - startTime`
4. Use `Math.floor(elapsed / msPerWord)` for target index
5. Only call `onWordChange` when advancing to new word
6. Cancel RAF with `cancelAnimationFrame(this.rafId)`
7. Auto-stop when reaching end: `targetIndex >= words.length`

Reference the complete implementation from RESEARCH.md Pattern 1 (lines 92-163). This is a verified pattern - do NOT simplify or "improve" the timing logic.

Create the file in lib/rsvp/ directory (create directory if needed).
  </action>
  <verify>
```bash
cat lib/rsvp/engine.ts | grep -E "(requestAnimationFrame|Math\.floor.*elapsed|msPerWord)"
npm run build
```
Verify: RAF loop exists, timestamp-based positioning present, build succeeds.
  </verify>
  <done>lib/rsvp/engine.ts exists with RSVPEngine class using RAF timing and timestamp-based positioning, build passes</done>
</task>

<task type="auto">
  <name>Task 3: Create ORP calculator</name>
  <files>lib/rsvp/orp-calculator.ts</files>
  <action>
Create Optimal Recognition Point calculator using 30-40% positioning based on eye movement research. This is CRITICAL - users train eye fixation patterns immediately, wrong ORP causes permanent eye strain.

Implementation requirements from RESEARCH.md Pattern 2:

**ORP formula (length-based weighting):**
- ≤2 chars: 50% (center)
- 3-5 chars: 35% (slightly left of center)
- 6-9 chars: 33% (one-third)
- >9 chars: 30% (further left)

**MUST handle:**
1. Leading/trailing punctuation (calculate on clean text, add offset back)
2. Word groups: ORP of FIRST word only (not middle word, not average)
3. Edge cases: empty string, only punctuation

**Export two functions:**
```typescript
export function calculateORP(text: string): number;
export function splitAtORP(text: string): [string, string, string];
```

**Test cases to verify correctness (from RESEARCH.md):**
```typescript
calculateORP("I") === 0           // "I" → index 0
calculateORP("the") === 1         // "the" → "t[h]e"
calculateORP("reading") === 2     // "reading" → "re[a]ding"
calculateORP("don't") === 1       // "don't" → "d[o]n't"
calculateORP("the quick") === 1   // Word group: ORP of "the"
```

Reference the complete implementation from RESEARCH.md Pattern 2 (lines 189-261). This is research-based - do NOT use `Math.floor(length/2)`.

Common mistakes to AVOID:
- ❌ Using `Math.floor(word.length / 2)` (wrong focal point)
- ❌ Not handling punctuation (ORP lands on punctuation)
- ❌ Calculating ORP for entire word group (should be first word)
- ❌ Not removing leading punctuation offset

Create in lib/rsvp/ directory.
  </action>
  <verify>
```bash
# Verify ORP ratios are in 30-40% range
cat lib/rsvp/orp-calculator.ts | grep -E "0\.(3[0-5]|[3-4][0-9])"

# Verify splitAtORP function exists
cat lib/rsvp/orp-calculator.ts | grep "splitAtORP"

npm run build
```
  </verify>
  <done>lib/rsvp/orp-calculator.ts exists with calculateORP and splitAtORP functions using 30-40% positioning, build passes</done>
</task>

<task type="auto">
  <name>Task 4: Create word grouper</name>
  <files>lib/rsvp/word-grouper.ts</files>
  <action>
Create fixed-size word grouping utility. Smart grouping (break at punctuation) is deferred to v2 per RESEARCH.md.

**Simple implementation for v1:**
```typescript
export function groupWords(text: string, wordsPerGroup: number): string[] {
  // Split on whitespace, filter empty strings
  const words = text.split(/\s+/).filter(Boolean);

  if (wordsPerGroup === 1) {
    return words; // No grouping needed
  }

  const groups: string[] = [];
  for (let i = 0; i < words.length; i += wordsPerGroup) {
    const chunk = words.slice(i, i + wordsPerGroup);
    groups.push(chunk.join(' '));
  }

  return groups;
}
```

This handles:
- Single word display (wordsPerGroup=1)
- Multi-word groups (2-5 words)
- Remainder words (last group may be smaller)

Smart grouping with punctuation detection is v2 enhancement (RESEARCH.md Pattern 5).

Create in lib/rsvp/ directory.
  </action>
  <verify>
```bash
cat lib/rsvp/word-grouper.ts | grep "groupWords"
npm run build
```
  </verify>
  <done>lib/rsvp/word-grouper.ts exists with groupWords function, build passes</done>
</task>

<task type="auto">
  <name>Task 5: Create Zustand stores</name>
  <files>
store/reading-store.ts
store/settings-store.ts
  </files>
  <action>
Create two Zustand stores: reading state (current word, position, playing status) and settings (WPM, grouping, persistence).

**store/reading-store.ts:**
```typescript
import { create } from 'zustand';

interface ReadingState {
  // Current reading state
  currentWord: string | null;
  currentIndex: number;
  totalWords: number;
  isPlaying: boolean;
  words: string[]; // Store grouped words array

  // Derived state
  progress: number; // 0-100

  // Actions
  setCurrentWord: (word: string, index: number) => void;
  setIsPlaying: (playing: boolean) => void;
  initialize: (words: string[]) => void;
  reset: () => void;
}

export const useReadingStore = create<ReadingState>((set, get) => ({
  currentWord: null,
  currentIndex: 0,
  totalWords: 0,
  isPlaying: false,
  words: [],
  progress: 0,

  setCurrentWord: (word, index) => set((state) => ({
    currentWord: word,
    currentIndex: index,
    progress: state.totalWords > 0 ? (index / state.totalWords) * 100 : 0,
  })),

  setIsPlaying: (playing) => set({ isPlaying: playing }),

  initialize: (words) => set({
    words,
    totalWords: words.length,
    currentIndex: 0,
    currentWord: words[0] || null,
    progress: 0,
    isPlaying: false,
  }),

  reset: () => set({
    currentWord: null,
    currentIndex: 0,
    totalWords: 0,
    isPlaying: false,
    words: [],
    progress: 0,
  }),
}));
```

**store/settings-store.ts (with persistence):**
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface SettingsState {
  wpm: number;
  wordsPerGroup: number;

  setWPM: (wpm: number) => void;
  setWordsPerGroup: (count: number) => void;
}

export const useSettingsStore = create<SettingsState>()(
  persist(
    (set) => ({
      wpm: 300,
      wordsPerGroup: 1,

      setWPM: (wpm) => set({ wpm }),
      setWordsPerGroup: (count) => set({ wordsPerGroup: count }),
    }),
    {
      name: 'rsvp-settings', // localStorage key
    }
  )
);
```

**Key aspects:**
- Selective subscription pattern enables: `useReadingStore((state) => state.currentWord)`
- Components only re-render when subscribed slice changes
- Settings persist via zustand/middleware
- Default 300 WPM (comfortable reading speed)
- Default 1 word per group (beginner-friendly)

Reference RESEARCH.md Pattern 3 for complete implementation (lines 303-384).

Create store/ directory if needed.
  </action>
  <verify>
```bash
cat store/reading-store.ts | grep "useReadingStore"
cat store/settings-store.ts | grep "persist"
npm run build
```
  </verify>
  <done>store/reading-store.ts and store/settings-store.ts exist with Zustand stores, persistence configured, build passes</done>
</task>

</tasks>

<verification>
**Module existence:**
```bash
ls -la lib/rsvp/
ls -la store/
```

**Build verification:**
```bash
npm run build
```

**Import verification (no runtime errors):**
```bash
# Check TypeScript compilation
npx tsc --noEmit
```

**Key pattern verification:**
```bash
# RAF timing uses timestamp-based positioning
grep "Math.floor.*elapsed" lib/rsvp/engine.ts

# ORP uses 30-40% ratios
grep -E "0\.(3[0-9]|[3-4][0-9])" lib/rsvp/orp-calculator.ts

# Zustand stores use selective subscriptions
grep "create" store/reading-store.ts store/settings-store.ts
```
</verification>

<success_criteria>
**Must be TRUE:**
1. ✓ npm build completes without errors
2. ✓ lib/rsvp/ contains engine.ts, orp-calculator.ts, word-grouper.ts
3. ✓ store/ contains reading-store.ts, settings-store.ts
4. ✓ RSVPEngine class uses requestAnimationFrame with timestamp-based positioning
5. ✓ calculateORP uses 30-40% ratios, not 50%
6. ✓ Zustand stores exported with create() pattern
7. ✓ Settings store wrapped with persist middleware
8. ✓ zustand and use-debounce in package.json

**Files created:** 7 (package.json modified, 6 new files)
**No UI yet** - this plan is pure engine logic
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rsvp-engine/02-01-SUMMARY.md` documenting:
- RAF timing implementation verified
- ORP calculation with correct ratios
- Zustand stores with selective subscriptions
- Dependencies installed
- Build passing
- Ready for React component integration (Plan 02)
</output>
